#!/usr/bin/env python3"""Class and function definitions for SDN state representation for AIRS.This module contains various classes and function definitions, as well as somebasic examples showing how to construct a representation of an SDN using theseprimitives and perform various operations on that state.The SDN network has two types of components: controllers andswitches.The data plane is made up of hosts and switches. Hosts are connected toswitches. Switches are linked to each other so packets can be passed from oneswitch to another when hosts need to communicate.The control plane is made up of switches and controllers. The control plane isconsidered to be "above" or "north" of the data plane, so controllers areconnected to switches via a so-called southbound link. Controllers overseeswitches, manage policies and intents, translate them to flow rules that theswitches apply to their flow tables.Many things could go wrong with the controller, the switch, the data planelinks, or the southbound links. In the mini example in this document, we onlyfocus on a component (either controller or switch) misbehaving and how torespond to that.In the future, situational awareness monitors, intrusion detection systems,etc., will let us know that the state or states of various SDN base objects arenot in a secure state. For now, we just simulate an attack on a controller orswitch by decreasing its health. This is not part of the planner's job. OnceAIRS determines that an action or response needs to be generated, the plannerneeds to choose from various response candidates. Currently, we only have threecandidate responses:    1) Restart the component    2) Replace the component with an alternative    3) Transfer responsibilities from the (faulty) component to a different        (existing) componentEach candidate response has cost and benefit associated with it. In fact, eachalternative component that is available to replace the faulty component has adifferent cost and benefit associated with it. For now, the planner needs todecide which candidate response to recommend to the AIRS system.There are 4 methods provided that apply the action the planner recommended.Even though we have example methods such as applying least cost alternative andapplying most benefit alternatives, the planner shouldn't limit itself tothose. There may be better way of choosing a response."""from domain_constants import *import RAE1_and_RAEplan as raeimport guifrom state import statefrom timer import globalTimer, DURATIONimport mathimport GLOBALSdef GetCostOfRestart(component_id):    return state.controllers[component_id].getRestartCostBenefit()['cost']DURATION.TIME = {    'applyRestart': GetCostOfRestart,    'applyAlternative': 5, }DURATION.COUNTER = {    'applyRestart': GetCostOfRestart,    'applyAlternative': 5, }def fail():    return FAILUREclass SDNBase(object):    """Base object class for links, hosts, and other SDN components."""    def __init__(self, id):        """Constructor for SDN base object.        Arguments:            id (str): Indentifier string.        """        self.id = id    def __str__(self) -> str:        """Return a string representation of this object (just the ID)."""        return 'id: ' + self.id    def __repr__(self) -> str:        """Return a complete string representation of this object."""        return repr(self.__dict__)class SDNComponent(SDNBase):    """SDN Component is the parent class for controller and switch."""    def __init__(self, id, platform, runtime, product, version, trust, health,                 alternatives, addl_state):        """Constructor for SDN component.        Arguments:            id (str): Identifier string.            platform (str): Software platform (e.g., Linux).            runtime (str): Softwate runtime (e.g., Java).            product (str): Software product name (e.g., ONOS).            version (str): Software version (e.g., v1.0).            trust (float): Trust level of component (ranges from 0.0 to 1.0).            health (float): Health of component (ranges from 0.0 to 1.0).            alternatives (list): List of alternative implementations.            addl_state (dict): Any other state info.        """        super().__init__(id)        self.platform = platform        self.runtime = runtime        self.product = product        self.version = version        self.trust = trust        self.health = health        self.alternatives = alternatives        self.addl_state = addl_state        # Set a flag to keep track of whether alt. costs have been computed        self.alternative_costs_computed = False    def getRestartCostBenefit(self) -> dict:        """Get the cost and benefit of restarting this component.        Cost and benefit (in all methods) are values from 0.0 to 1.0.        Right now the values may not make a lot of sense, but exist just for        the planner to use as a comparison/metric.        Returns:            A dictionary with values for 'cost' and 'benefit'.        """        cost = 0.2        benefit = 1.0 - self.health        return {'cost': cost, 'benefit': benefit}    def getTransferCostBenefit(self, other) -> dict:        """Get the cost and benefit of transferring responsibilities.        A component's responsibilities could be transferred to another        component when it is malfunctioning, assuming that the replacement is        an already functioning component of the same type.        The replacement takes over self's underlying components as well as        maintaining its own.        Arguments:            other (:obj:`SDNComponent`): Replacement component.        Returns:            A dictionary with values for 'cost' and 'benefit'.        """        # Compare the ways in which the components differ        numdiff = 0        if self.platform != other.platform:            numdiff += 1        if self.product != other.product:            numdiff += 1        if self.runtime != other.runtime:            numdiff += 1        if self.version != other.version:            numdiff += 1        # The more different the two components are, the costlier the change        # (but the more benefit)        cost = numdiff * 0.3 + 0.2        benefit = (numdiff - 0)/4        return {'cost': cost, 'benefit': benefit}    def updateAlternativesCostBenefit(self):        """Update costs/benefits of each alternative.        Each SDN Component has a list of alternatives that can take its place.        We calculate the cost and benefit of each alternative for the given SDN        component.        The cost and benefit of the alternatives depends on how diverse (in        terms of platform, product, runtime, and version) they are from the        current values. In theory, the more diverse the alternative is to the        original, the more benefit it would provide, and it would also cost        more.        If an SDN component is replaced with one of its alternates, self may no        longer have same platform, product, runtime and version it had before.        Therefore, the cost and benefits of its alternates needs to be uodated.        """        for item in self.alternatives:            numdiff = 0            if item['instance'].platform != self.platform:                numdiff += 1            if item['instance'].product != self.product:                numdiff += 1            if item['instance'].runtime != self.runtime:                numdiff += 1            if item['instance'].version != self.version:                numdiff += 1            item['cost'] = numdiff / 2 + 0.3            item['benefit'] = numdiff * 0.25        # This flag keeps track of whether the cost/benefit of the alternatives        # have been updated        self.alternative_costs_computed = True    def getLeastCostAlternative(self) -> dict:        """Get the alternative with least cost from this object's list.        This method goes through the list of alternatives and returns the one        (if any) that has the least cost.        It is just a sample method. Part of this selection would be used in the        actual planner and not here.        Returns:            The alternative with least cost, or None.        """        # Update alternative costs, if necessary        if not self.alternative_costs_computed:            self.updateAlternativesCostBenefit()        # If alternatives are available, find the one with least cost        match = None        mincost = None        if len(self.alternatives) > 0:            for item in self.alternatives:                if mincost is None or item['cost'] < mincost:                    mincost = item['cost']                    match = item        return match    def getMostBenefitAlternative(self) -> dict:        """Get the alternative with the most benefit from this object's list.        This method goes through the list of alternatives and returns the one        (if any) that has the most benefit.        It is just a sample method. Part of this selection would be used in the        actual planner and not here.        Returns:            The alternative with least cost, or None.        """        # Update alternative costs, if necessary        if not self.alternative_costs_computed:            self.updateAlternativesCostBenefit()        # If alternatives are available, find the one with most benefit        match = None        maxbenefit = None        if len(self.alternatives) > 0:            for item in self.alternatives:                if maxbenefit is None or item['benefit'] > maxbenefit:                    maxbenefit = item['benefit']                    match = item        return match# commanddef applyAlternative(component_id, alt):    """Apply the given alternative to this component.    This method updates this component with the values from the selected    alternative.    For example, we could call getMostBenefitAlternative() and use the    returned alternative to apply to the current component.    Arguments:        alt (dict): The alternative to apply.    """    state.controllers[component_id].platform = alt['instance'].platform    state.controllers[component_id].runtime = alt['instance'].runtime    state.controllers[component_id].product = alt['instance'].product    state.controllers[component_id].version = alt['instance'].version    # Reset the recomputation flag to False, because the applied    # alternative may have different values from the original component.    # If there are differences of platform, runtime, product, or version,    # then cost and benefit need to be recomputed.    state.controllers[component_id].alternative_costs_computed = False    return SUCCESSclass Controller(SDNComponent):    """Class representing an SDN controller.    A controller controls one or more switches via southbound links, but also    keeps track of the state of the whole data plane network. Thus, a    controller maintains references to all of the objects that together    compose the whole software-defined network.    """    def __init__(self, id, platform, runtime, product, version, trust=0.0,                 health=0.0, bandwidth=0.0, alternatives=None, switches=None,                 dplinks=None, sblinks=None, intents=None, addl_state=None):        """Constructor for controller.        Arguments:            platform (str): SDN controller platform.            runtime (str): SDN controller runtime.            product (str): SDN controller software product name.            version (str): SDN controller software version.            trust (float): How much the controller is trusted (ranges from 0.0                to 1.0).            health (float): How healthy is the controller (ranges from 0.0 to                1.0). Deteriorates as attacks occur or performance degrades.            bandwidth (float): For now, is defined as the sum of the capacity                of the southbound links.            alternatives (list): List of alternate controllers that could                replace this one.            switches (list): List of switches connected to this controller.            dplinks (list): List of links between the switches.            sblinks (list): List of links between the switches and the                controller.            intents (list): List of intents between hosts (these are translated                to flow rules in the switches). Note: currently not used.            addl_state (dict): Any other state info. Note: currently not used.        """        super().__init__(id, platform, runtime, product, version,                         trust, health,                         alternatives if alternatives is not None else [],                         addl_state if addl_state is not None else {})        self.bandwidth = bandwidth        self.switches = switches if switches is not None else []        self.dplinks = dplinks if dplinks is not None else []        self.sblinks = sblinks if sblinks is not None else []        self.intents = intents if intents is not None else []    def __str__(self) -> str:        """Return a string representation of this controller."""        return ('controller ' + str(self.id)                + ' with health ' + str(self.health)                + ' and total bandwidth ' + str(self.bandwidth))class Switch(SDNComponent):    """Class representing an SDN switch.    A switch is connected to other switches on the data plane, may have one or    more hosts connected to it, and communicates with a controller via a    southbound link.    """    def __init__(self, id, platform, runtime, product, version, trust=0.0,                 health=0.0, alternatives=None, links=None, addl_state=None):        """Constructor for switch.        Arguments:            platform (str): Switch platform.            runtime (str): Switch runtime.            product (str): Switch software product name.            version (str): Switch software version.            trust (float): How much the switch is trusted (ranges from 0.0 to                1.0).            health (float): How healthy is the switch (ranges from 0.0 to 1.0).                Deteriorates as attacks occur or performance degrades.            alternatives (list): List of alternate switches that could replace                this one.            links (list): List of links to other switches on the data plane.            addl_state (dict): Any other state info. Note: currently not used.        """        super().__init__(id, platform, runtime, product, version,                         trust, health,                         alternatives if alternatives is not None else [],                         addl_state if addl_state is not None else {})        self.links = links if links is not None else []    def __str__(self) -> str:        """Return a string representation of this switch."""        return ('switch ' + str(self.id)                + ' with health ' + str(self.health)                + ' connected to ' + str(len(self.links)) + ' other switches')class Host(SDNBase):    """Class representing a host on the data plane.    A host is connected to a switch.    """    def __init__(self, id, ipAddress, mac, switch):        """Constructor for host.        Arguments:            id: Identifier string.            ipAddress: IPv4 address of host.            mac: MAC address of host.            switch: Switch that the host is connected to.        """        super().__init__(id)        self.ipAddress = ipAddress        self.mac = mac        self.switch = switch    def __str__(self) -> str:        """Return a string representation of this host."""        return ('host ' + str(self.id)                + ' connected to switch ' + self.switch.id)class Link(SDNBase):    """A link defines a two-way connection between two components.    Even though it has src and dst, a link is considered bi-directional.    """    def __init__(self, src: SDNComponent, dst: SDNComponent, capacity: float):        """Constructor for a link between two components.        Arguments:            src (:obj:`SDNComponent`): Source component.            dst (:obj:`SDNComponent`): Destination component.            capacity (float): Maximum bandwidth that the link can support.        """        super().__init__('')        self.src = src        self.dst = dst        self.capacity = capacity    def __str__(self) -> str:        """Return a string representation of this link."""        return ('link between src=' + str(self.src.id)                + ' <--> dst=' + str(self.dst.id)                + ' with capacity ' + str(self.capacity))class DPLink(Link):    """A data-plane link defines a connection between two switches."""    def __init__(self, src: Switch, dst: Switch, capacity: float):        """Constructor for data-plane link.        Arguments:            src (:obj:`Switch`): First switch.            dst (:obj:`Switch`): Second switch.            capacity (float): Maximum bandwidth that the link can support.        """        super().__init__(src, dst, capacity)    def __str__(self) -> str:        """Return a string representation of this data plane link."""        return ('data plane link between switch ' + str(self.src.id)                + ' <--> switch ' + str(self.dst.id)                + ' with capacity ' + str(self.capacity))class SBLink(Link):    """A southbound link defines a connection between controller and switch."""    def __init__(self, controller: Controller, switch: Switch,                 capacity: float):        """Constructor for southbound link.        Arguments:            src (:obj:`Controller`): The controller.            dst (:obj:`Switch`): The switch.            capacity (float): Maximum bandwidth that the link can support.        """        super().__init__(controller, switch, capacity)    def __str__(self) -> str:        """Return a string representation of this southbound link."""        return ('southbound link between controller ' + str(self.src.id)                + ' <--> switch= ' + str(self.dst.id)                + ' with capacity ' + str(self.capacity))class Intent(SDNBase):    """Defines the intent that two hosts be able to communicate.    Intents are bi-directional and defined between hosts as endpoints,    optionally with certain quality-of-service (QoS) requirements.    Note: currently not used.    """    def __init__(self, host1, host2, qos=None):        """Constructor for intent.        Arguments:            host1 (:obj:`Host`): First host.            host2 (:obj:`Host`): Second host.            qos (float): Quality of service requirement (optional).        """        super().__init__('')        self.host1 = host1        self.host2 = host2        self.qos = qos    def __str__(self) -> str:        """Return a string representation of this intent."""        return ('allow communication between host ' + str(self.host1.id)                + ' and host ' + str(self.host2.id)                + ('' if self.qos is None else (' with bandwidth of '                                                + str(self.qos))))# commanddef applyRestart(component_id):    """Apply the effects of restarting the given component.    Arguments:        component (:obj:`SDNComponent`): Controller or switch.    """    state.controllers[component_id].health = 1.0    state.controllers[component_id].trust = 0.8    return SUCCESS# commanddef defendController(controller_id):    """Defend the given controller.    Note: this is just a placeholder method for something the planner would do.    """    if state.controllers[controller_id].health < 0.25:        # select optimal plan from given options:        # restart        # replace - same        # replace - diff/multiple variations and costs        # transfer        gui.Simulate('action taken')    return SUCCESS# commanddef applyTransfer(component1_id, component2_id):    """Apply the effects of transferring responsibilities to a new component.    Arguments:        component1 (:obj:`SDNComponent`): Malfunctioning ontroller or switch.        component2 (:obj:`SDNComponent`): Controller or switch to take over.    """    state.controllers[component1_id].health = 0.0    state.controllers[component1_id].trust = 0.0    state.controllers[component2_id].trust = 0.95    return SUCCESS# method for restartdef Restart_Method1_applyRestart(component_id):    rae.do_command(applyRestart, component_id)# method for recoverydef Recovery_Method0_DoNothing(component_id):    gui.Simulate("Recovering component")    rae.do_command(fail)# method for recoverydef Recovery_Method1_LeastCostAlternative(component_id):    """Apply the least cost alternative for the given component.    Arguments:        component (:obj:`SDNComponent`): Controller or switch.    """    component = state.controllers[component_id]    match = component.getLeastCostAlternative()    if match is not None:        rae.do_command(applyAlternative, component.id, match)        component.health = 1.0        component.trust = 0.85        gui.Simulate('component has been replaced with a cost of '              + str(match['cost']) + ' using ' + str(match['instance'].id))    else:        rae.do_command(fail)# method for recoverydef Recovery_Method2_MostBenefitAlternative(component_id):    """Apply the most benefit alternative for the given component.    Arguments:        component (:obj:`SDNComponent`): Controller or switch.    """    component = state.controllers[component_id]    match = component.getMostBenefitAlternative()    if match is not None:        rae.do_command(applyAlternative, component.id, match)        component.health = 1.0        component.trust = 0.85        gui.Simulate('component has been replaced with a benefit of '              + str(match['benefit']) + ' using ' + str(match['instance'].id))    else:        rae.do_command(fail)# command to simulate attackdef simComponentAttack(component_id, attacklevel=0.1):    """Simulate the effect an attack by decreasing the component's health.    Simply reduces the health of the given component by the given amount.    Arguments:        component (:obj:`SDNComponent`): Controller or switch.        attacklevel (float): Strength of attack (defaults to 0.1).    """    if state.controllers[component_id].health > attacklevel:        state.controllers[component_id].health -= attacklevel    else:        state.controllers[component_id].health = 0.0#The set of rigid variablesrv = RV()#The set of commandsrae.declare_commands([    applyRestart,    applyAlternative,    simComponentAttack,    fail    ])rae.declare_task('recover', 'component_id')rae.declare_task('restart', 'component_id')#The set of tasks and their refinement methodsrae.declare_methods('recover',     Recovery_Method0_DoNothing,    Recovery_Method1_LeastCostAlternative,    Recovery_Method2_MostBenefitAlternative    )rae.declare_methods('restart',     Restart_Method1_applyRestart,    )#from env_airsSDN import *# Sunandita: I have moved the parts of runExample to the problems# The problems can be found in the folder shared/problems/SDNdef runExample():    """Run through a basic example using the primitives defined in this module.    This function creates a toy SDN network and performs various tests and    exercises on the components.    """    # Define common controller alternatives    c_alt1 = Controller('alt-1', 'Debian', 'Java2', 'OpenDaylight', '1.15.0')    c_alt2 = Controller('alt-2', 'Fedora', 'Java', 'ONOS', '1.15.0')    c_alt3 = Controller('alt-3', 'Ubuntu', 'Java', 'OpenDaylight', 'hydrogen')    c_alt4 = Controller('alt-4', 'Ubuntu', 'Java', 'ONOS', '1.12.0')    # For testing, last alternative has same config as c1    # Create 2 controllers, c1 and c2 with alternatives    c1 = Controller('c1', 'Ubuntu', 'Java', 'ONOS', '1.12.0',                    trust=1.0, health=1.0,                    alternatives=[{'instance': c_alt1}, {'instance': c_alt3},                                  {'instance': c_alt4}])    c2 = Controller('c2', 'Debian', 'Java', 'OpenDaylight', 'Oxygen-SR3',                    trust=1.0, health=1.0,                    alternatives=[{'instance': c_alt1}, {'instance': c_alt2},                                  {'instance': c_alt3}])    # Test computation of costs and benefits    c1.updateAlternativesCostBenefit()    print('The costs and benefits of the alternative controllers for c1:')    for item in c1.alternatives:        print('  cost    for ' + str(item['instance'].id) + ' is '              + str(item['cost']))        print('  benefit for ' + str(item['instance'].id) + ' is '              + str(item['benefit']))    print()    c2.updateAlternativesCostBenefit()    print('The costs and benefits of the alternative controllers for c2:')    for item in c2.alternatives:        print('  cost    for ' + str(item['instance'].id) + ' is '              + str(item['cost']))        print('  benefit for ' + str(item['instance'].id) + ' is '              + str(item['benefit']))    print()    # Define common switch alternatives    s_alt1 = Switch('alt-1', 'Ubuntu', 'Linux kernel 4.4.0',                    'Open vSwitch', '2.9.2')    s_alt2 = Switch('alt-2', 'Fedora', 'Linux kernel 3.19.0',                    'Open vSwitch', '2.8')    s_alt3 = Switch('alt-3', 'Debian', 'Linux kernel 4.3.0',                    'Open vSwitch', '2.7')    # Create 6 switches and attach the alternatives to them    s1 = Switch('s1', 'Ubuntu', 'Linux kernel 4.4.0', 'Open vSwitch', '2.0.2',                trust=1.0, health=1.0,                alternatives=[{'instance': s_alt1}, {'instance': s_alt2}])    s2 = Switch('s2', 'Ubuntu', 'Linux kernel 4.4.0', 'Open vSwitch', '2.9.2',                trust=0.75, health=0.75,                alternatives=[{'instance': s_alt1}, {'instance': s_alt3}])    s3 = Switch('s3', 'Ubuntu', 'Linux kernel 4.4.0', 'Open vSwitch', '2.9.2',                trust=1.0, health=1.0,                alternatives=[{'instance': s_alt1}, {'instance': s_alt2},                              {'instance': s_alt3}])    s4 = Switch('s4', 'Ubuntu', 'Linux kernel 4.4.0', 'Open vSwitch', '2.9.2',                trust=0.75, health=0.75,                alternatives=[{'instance': s_alt1}])    s5 = Switch('s5', 'Ubuntu', 'Linux kernel 4.4.0', 'Open vSwitch', '2.9.2',                trust=1.0, health=1.0,                alternatives=[{'instance': s_alt1}, {'instance': s_alt2}])    s6 = Switch('s6', 'Ubuntu', 'Linux kernel 4.4.0', 'Open vSwitch', '2.9.2',                trust=1.0, health=1.0,                alternatives=[{'instance': s_alt2}, {'instance': s_alt3}])    # Controller talks to  switches    c1.switches.extend([s1, s2, s3])    c2.switches.extend([s4, s5, s6])    # Create SB links between controller and switches. Randomly defined    # capacity 10 for each link, for now.    sb1 = SBLink(c1, s1, 10)    sb2 = SBLink(c1, s2, 10)    sb3 = SBLink(c1, s3, 10)    sb4 = SBLink(c2, s4, 10)    sb5 = SBLink(c2, s5, 10)    sb6 = SBLink(c2, s6, 10)    # Add the sblinks to the controller    c1.sblinks.extend([sb1, sb2, sb3])    c2.sblinks.extend([sb4, sb5, sb6])    # Calculate bandwidth of each controller which is just the sum of its    # southbound links (sblinks)    c1.bandwidth = sb1.capacity + sb2.capacity + sb3.capacity    c2.bandwidth = sb4.capacity + sb5.capacity + sb6.capacity    # Add data plane links between switches s1, s2, and s3    l1 = DPLink(s1, s2, 10)    l2 = DPLink(s2, s3, 10)    l3 = DPLink(s1, s3, 10)    c1.dplinks.extend([l1, l2, l3])    # Add data plane links between s4, s5, and s6    l4 = DPLink(s4, s5, 10)    l5 = DPLink(s5, s6, 10)    l6 = DPLink(s6, s4, 10)    c2.dplinks.extend([l4, l5, l6])    # Add hosts to switches (c1 is responsible for h1, h2, and h3, which are    # connected to s1, s2, and s3 respectively; c2 is responsible for h4, and    # h6, which are connected to s4, and s6, respectively)    h1 = Host('h1', '10.1.1.1', '00:00:00:00:B1:02', s1)    h2 = Host('h2', '10.1.1.2', '00:00:00:00:B1:03', s2)    h3 = Host('h3', '10.1.1.3', '00:00:00:00:A1:33', s3)    h4 = Host('h4', '10.1.1.4', '00:00:00:00:B1:04', s4)    h6 = Host('h6', '10.1.1.6', '00:00:00:00:A1:06', s6)    # Is host h2 connected to switch s2?    # Not needed, but may be useful at some point    print('Test host-switch connectivity:')    if h2.switch.id == s2.id:        print('  h2 is connected to s2')    else:        print('  h2 is not connected to s2')    print()    # Define intents, add them to controller    i1 = Intent(h1, h2, 5)    i2 = Intent(h2, h3, 3)    i3 = Intent(h3, h1, 5)    c1.intents.extend([i1, i2, i3])    i4 = Intent(h4, h6, 5)    c2.intents.extend([i4])    # Test host-host connectivity via intents    print('Test host-host connectivity (intents):')    if haveIntentForHosts(h1, h2, c1):        print('  hosts ' + str(h1.id)              + ' and ' + str(h2.id) + ' can communicate')    else:        print('  hosts ' + str(h1.id)              + ' and ' + str(h2.id) + ' cannot communicate')    print()    # Get & print cnnectivity matrix    print('Connectivity matrix for controller c1:')    print(getConnMatrix(c1))    # Launch an attack    simComponentAttack(c1, 0.6)    print('Controller health value is: ' + str(c1.health) + ' after attack')    print()    # Try least-cost alternative    applyLeastCostAlternative(c1)    print('Controller health value is: ' + str(c1.health) + ' after response')    print()    # Launch another attack    simComponentAttack(c2, 0.7)    print('Controller health value is: ' + str(c2.health) + ' after attack')    print()    # Try most-benefit alternative    applyMostBenefitAlternative(c2)    print('Controller health value is: ' + str(c2.health) + ' after response')    print()# functions not being used currentlydef getConnMatrix(controller: Controller) -> str:    """Get a string representation of the connectivity matrix for this network.    Iterates over all switches that the controller is connected to to return    the connectivity matrix from the perspective of the given controller.    Arguments:        controller (:obj:`Controller`): The controller.    Returns:        A string representation of the connectivity matrix.    """    result = ''    header = '   '    for switch_row in controller.switches:        header += switch_row.id.ljust(3)    result += header + '\n'    for switch_row in controller.switches:        curr_row = switch_row.id.ljust(3) + ' '        for switch_col in controller.switches:            are_conn = False            for cur_link in controller.dplinks:                if cur_link.src == switch_row or cur_link.dst == switch_row:                    if (cur_link.src == switch_col                            or cur_link.dst == switch_col):                        are_conn = True                        break            if are_conn:                curr_row += str(1).ljust(3)            else:                curr_row += str(0).ljust(3)        result += curr_row + '\n'    return resultdef simLinkAttack(component, link, attacklevel):    """Placeholder: have a way to simulate attacks on a link."""    passdef haveIntentForHosts(host1: Host, host2: Host, controller: Controller):    """Check whether two hosts can communicate.    Given two hosts, this method checks if they can communiate by examining if    there are any intents defined with the hosts as given endpoints.    Note: currently not used.    Arguments:        host1 (:obj:`Host`): First host.        host2 (:obj:`Host`): Second host.        controller (:obj:`Controller`): The controller.    Returns:        True if there exists an intent referencing the two hosts, false        otherwise.    """    for cur_int in controller.intents:        have_intent = False        if ((cur_int.host1 == host1 or cur_int.host1 == host2)                and (cur_int.host2 == host2 or cur_int.host2 == host1)):            have_intent = True            break    return have_intent